**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `testnet`
- **Package ID:** `0xbab08a38bc4814d96cf8edaaf731a17cabf02f1f606f3cb949c48ae5691443ee`
- **Module Name:** `contract`
- **Available Methods:**

  * `create` (constant: `CREATE`)
  * `update` (constant: `UPDATE`)
  * `transfer_ownership` (constant: `TRANSFER_OWNERSHIP`)

---

# **Move Contract: `contract/patient/sources/patient.move`**

```move
module patient::contract {
use std::string;
public struct MedicalRecord has key {
id: UID,
owner: address,
patient_name: string::String,
age: u8,
diagnosis: string::String,
medications: string::String,
notes: string::String,
last_updated_ms: u64,
}
public fun create(
patient_name: string::String,
age: u8,
diagnosis: string::String,
medications: string::String,
notes: string::String,
last_updated_ms: u64,
ctx: &mut TxContext
) {
transfer::share_object(MedicalRecord {
id: object::new(ctx),
owner: ctx.sender(),
patient_name,
age,
diagnosis,
medications,
notes,
last_updated_ms,
})
}
public fun update(
record: &mut MedicalRecord,
patient_name: string::String,
age: u8,
diagnosis: string::String,
medications: string::String,
notes: string::String,
last_updated_ms: u64,
ctx: &TxContext
) {
assert!(record.owner == ctx.sender(), 0);
record.patient_name = patient_name;
record.age = age;
record.diagnosis = diagnosis;
record.medications = medications;
record.notes = notes;
record.last_updated_ms = last_updated_ms;
}
public fun transfer_ownership(
record: &mut MedicalRecord,
new_owner: address,
ctx: &TxContext
) {
assert!(record.owner == ctx.sender(), 0);
record.owner = new_owner;
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client"

/**
 * ============================================================================
 * IOTA CONTRACT INTEGRATION HOOK
 * ============================================================================
 * 
 * This hook contains ALL the contract interaction logic.
 * 
 * To customize your dApp, modify the configuration section below.
 * 
 * ============================================================================
 */

import { useState, useEffect } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import { useNetworkVariable } from "@/lib/config"
import type { IotaObjectData } from "@iota/iota-sdk/client"

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================
// Change these values to match your Move contract

export const CONTRACT_MODULE = "contract" // Your Move module name
export const CONTRACT_METHODS = {
  CREATE: "create",
  UPDATE: "update",
  TRANSFER_OWNERSHIP: "transfer_ownership",
} as const

// ============================================================================
// DATA EXTRACTION
// ============================================================================
// Modify this to extract data from your contract's object structure

type ParsedRecord = {
  owner: string
  patientName: string
  age: number
  diagnosis: string
  medications: string
  notes: string
  lastUpdatedMs: number
}

function getObjectFields(data: IotaObjectData): ParsedRecord | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType)
    return null
  }
  
  const fields = data.content.fields as any
  if (!fields) {
    console.log("No fields found in object data")
    return null
  }
  
  // Log the actual structure for debugging
  console.log("Object fields structure:", JSON.stringify(fields, null, 2))
  
  const asString = (val: unknown) => (typeof val === "string" ? val : val ? String(val) : "")
  const owner = asString(fields.owner)
  const patientName = asString(fields.patient_name)
  const diagnosis = asString(fields.diagnosis)
  const medications = asString(fields.medications)
  const notes = asString(fields.notes)

  const parseNum = (val: unknown) => {
    if (typeof val === "number") return val
    if (typeof val === "string") return parseInt(val, 10)
    return NaN
  }

  const age = parseNum(fields.age)
  const lastUpdatedMs = parseNum(fields.last_updated_ms)

  if (!owner || isNaN(age) || isNaN(lastUpdatedMs)) {
    console.log("Invalid record fields", { owner, age, lastUpdatedMs })
    return null
  }

  return {
    owner,
    patientName,
    age,
    diagnosis,
    medications,
    notes,
    lastUpdatedMs,
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export interface ContractData {
  patientName: string
  age: number
  diagnosis: string
  medications: string
  notes: string
  lastUpdatedMs: number
  owner: string
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  createRecord: (input: CreateRecordInput) => Promise<void>
  updateRecord: (input: UpdateRecordInput) => Promise<void>
  transferOwnership: (newOwner: string) => Promise<void>
  clearObject: () => void
}

export type CreateRecordInput = {
  patientName: string
  age: number
  diagnosis: string
  medications: string
  notes: string
  lastUpdatedMs: number
}

export type UpdateRecordInput = CreateRecordInput

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const address = currentAccount?.address
  const packageId = useNetworkVariable("packageId")
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()
  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)

  // Load object ID from URL hash
  useEffect(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.slice(1)
      if (hash) setObjectId(hash)
    }
  }, [])

  // Fetch object data
  const { data, isPending: isFetching, error: queryError, refetch } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!objectId,
    }
  )

  // Extract fields
  const fields = data?.data ? getObjectFields(data.data) : null
  const isOwner = fields?.owner.toLowerCase() === address?.toLowerCase()
  
  // Check if object exists but data extraction failed
  const objectExists = !!data?.data
  const hasValidData = !!fields

  // Create record
  const createRecord = async (input: CreateRecordInput) => {
    if (!packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      setHash(undefined)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [
          tx.pure.string(input.patientName),
          tx.pure.u8(input.age),
          tx.pure.string(input.diagnosis),
          tx.pure.string(input.medications),
          tx.pure.string(input.notes),
          tx.pure.u64(input.lastUpdatedMs),
        ],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CREATE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              })
              const newObjectId = effects?.created?.[0]?.reference?.objectId
              if (newObjectId) {
                setObjectId(newObjectId)
                if (typeof window !== "undefined") {
                  window.location.hash = newObjectId
                }
                // Reset loading - the query will handle its own loading state
                setIsLoading(false)
              } else {
                setIsLoading(false)
                console.warn("No object ID found in transaction effects")
              }
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError)
              setIsLoading(false)
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error creating object:", err)
      setIsLoading(false)
    }
  }

  // Update record
  const updateRecord = async (input: UpdateRecordInput) => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [
          tx.object(objectId),
          tx.pure.string(input.patientName),
          tx.pure.u8(input.age),
          tx.pure.string(input.diagnosis),
          tx.pure.string(input.medications),
          tx.pure.string(input.notes),
          tx.pure.u64(input.lastUpdatedMs),
        ],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.UPDATE}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error updating:", err)
      setIsLoading(false)
    }
  }

  // Transfer ownership
  const transferOwnership = async (newOwner: string) => {
    if (!objectId || !packageId) return

    try {
      setIsLoading(true)
      setTransactionError(null)
      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId), tx.pure.address(newOwner)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.TRANSFER_OWNERSHIP}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error transferring ownership:", err)
      setIsLoading(false)
    }
  }

  const contractData: ContractData | null = fields
    ? {
        patientName: fields.patientName,
        age: fields.age,
        diagnosis: fields.diagnosis,
        medications: fields.medications,
        notes: fields.notes,
        lastUpdatedMs: fields.lastUpdatedMs,
        owner: fields.owner,
      }
    : null

  const clearObject = () => {
    setObjectId(null)
    setTransactionError(null)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }

  const actions: ContractActions = {
    createRecord,
    updateRecord,
    transferOwnership,
    clearObject,
  }

  const contractState: ContractState = {
    isLoading: (isLoading && !objectId) || isPending || isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    data: contractData,
    actions,
    state: contractState,
    objectId,
    isOwner,
    objectExists,
    hasValidData,
  }
}


```

---

# File 2: `components/sample.tsx`

```tsx
"use client"

/**
 * ============================================================================
 * IOTA DAPP INTEGRATION COMPONENT
 * ============================================================================
 * 
 * This is the main integration component for your IOTA dApp.
 * 
 * All the contract logic is in hooks/useContract.ts
 * 
 * To customize your dApp, modify this file.
 * 
 * ============================================================================
 */

import { FormEvent, useEffect, useMemo, useState } from "react"
import { useCurrentAccount } from "@iota/dapp-kit"
import { useContract } from "@/hooks/useContract"
import { Button, Container, Flex, Heading, Text } from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const { data, actions, state, objectId, isOwner, objectExists, hasValidData } = useContract()

  const [createForm, setCreateForm] = useState({
    patientName: "",
    age: "",
    diagnosis: "",
    medications: "",
    notes: "",
  })

  const [updateForm, setUpdateForm] = useState({
    patientName: "",
    age: "",
    diagnosis: "",
    medications: "",
    notes: "",
  })

  const [transferTo, setTransferTo] = useState("")
  
  const isConnected = !!currentAccount

  // Prefill update form when data loads
  useEffect(() => {
    if (data) {
      setUpdateForm({
        patientName: data.patientName,
        age: String(data.age),
        diagnosis: data.diagnosis,
        medications: data.medications,
        notes: data.notes,
      })
    }
  }, [data])

  const formattedDate = useMemo(() => {
    if (!data) return ""
    const d = new Date(data.lastUpdatedMs)
    return isNaN(d.getTime()) ? String(data.lastUpdatedMs) : d.toLocaleString()
  }, [data])

  const handleCreate = async (e: FormEvent) => {
    e.preventDefault()
    const ageNum = parseInt(createForm.age, 10)
    if (isNaN(ageNum)) return
    await actions.createRecord({
      patientName: createForm.patientName,
      age: ageNum,
      diagnosis: createForm.diagnosis,
      medications: createForm.medications,
      notes: createForm.notes,
      lastUpdatedMs: Date.now(),
    })
  }

  const handleUpdate = async (e: FormEvent) => {
    e.preventDefault()
    if (!data) return
    const ageNum = parseInt(updateForm.age, 10)
    if (isNaN(ageNum)) return
    await actions.updateRecord({
      patientName: updateForm.patientName,
      age: ageNum,
      diagnosis: updateForm.diagnosis,
      medications: updateForm.medications,
      notes: updateForm.notes,
      lastUpdatedMs: Date.now(),
    })
  }

  const handleTransfer = async (e: FormEvent) => {
    e.preventDefault()
    if (!transferTo) return
    await actions.transferOwnership(transferTo)
    setTransferTo("")
  }

  if (!isConnected) {
    return (
      <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", padding: "1rem" }}>
        <div style={{ maxWidth: "500px", width: "100%" }}>
          <Heading size="6" style={{ marginBottom: "1rem" }}>IOTA dApp</Heading>
          <Text>Please connect your wallet to interact with the contract.</Text>
        </div>
      </div>
    )
  }

  return (
    <div style={{ minHeight: "100vh", padding: "1rem", background: "var(--gray-a2)" }}>
      <Container style={{ maxWidth: "800px", margin: "0 auto" }}>
        <Heading size="6" style={{ marginBottom: "2rem" }}>Hồ sơ bệnh án (IOTA Move)</Heading>

        {!objectId ? (
          <form onSubmit={handleCreate}>
            <div style={{ display: "grid", gap: "0.75rem", marginBottom: "1rem" }}>
              <Text size="3" weight="medium">Tạo hồ sơ mới</Text>
              <input
                required
                placeholder="Họ tên"
                value={createForm.patientName}
                onChange={(e) => setCreateForm({ ...createForm, patientName: e.target.value })}
                style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
              />
              <input
                required
                type="number"
                min={0}
                placeholder="Tuổi"
                value={createForm.age}
                onChange={(e) => setCreateForm({ ...createForm, age: e.target.value })}
                style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
              />
              <input
                required
                placeholder="Chẩn đoán"
                value={createForm.diagnosis}
                onChange={(e) => setCreateForm({ ...createForm, diagnosis: e.target.value })}
                style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
              />
              <input
                placeholder="Thuốc"
                value={createForm.medications}
                onChange={(e) => setCreateForm({ ...createForm, medications: e.target.value })}
                style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
              />
              <textarea
                placeholder="Ghi chú"
                value={createForm.notes}
                onChange={(e) => setCreateForm({ ...createForm, notes: e.target.value })}
                style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)", minHeight: 80 }}
              />
            </div>
            <Button
              size="3"
              type="submit"
              disabled={state.isPending}
            >
              {state.isPending ? (
                <>
                  <ClipLoader size={16} style={{ marginRight: "8px" }} />
                  Đang tạo...
                </>
              ) : (
                "Tạo hồ sơ"
              )}
            </Button>
            {state.error && (
              <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--red-11)" }}>
                  Error: {(state.error as Error)?.message || String(state.error)}
                </Text>
              </div>
            )}
          </form>
        ) : (
          <div>
            {state.isLoading && !data ? (
              <Text>Loading object...</Text>
            ) : state.error ? (
              <div style={{ padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--red-11)", display: "block", marginBottom: "0.5rem" }}>
                  Error loading object
                </Text>
                <Text size="2" style={{ color: "var(--red-11)" }}>
                  {state.error.message || "Object not found or invalid"}
                </Text>
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  Object ID: {objectId}
                </Text>
                <Button
                  size="2"
                  variant="soft"
                  onClick={actions.clearObject}
                  style={{ marginTop: "1rem" }}
                >
                  Clear & Create New
                </Button>
              </div>
            ) : objectExists && !hasValidData ? (
              <div style={{ padding: "1rem", background: "var(--yellow-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--yellow-11)" }}>
                  Object found but data structure is invalid. Please check the contract structure.
                </Text>
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  Object ID: {objectId}
                </Text>
              </div>
            ) : data ? (
              <div>
                <div style={{ marginBottom: "1rem", padding: "1rem", background: "var(--gray-a3)", borderRadius: "8px" }}>
                  <Text size="2" style={{ display: "block", marginBottom: "0.5rem" }}>Thông tin hồ sơ</Text>
                  <Heading size="7">{data.patientName}</Heading>
                  <Text size="2" style={{ display: "block", marginTop: "0.25rem" }}>Tuổi: {data.age}</Text>
                  <Text size="2" style={{ display: "block", marginTop: "0.25rem" }}>Chẩn đoán: {data.diagnosis}</Text>
                  <Text size="2" style={{ display: "block", marginTop: "0.25rem" }}>Thuốc: {data.medications || "—"}</Text>
                  <Text size="2" style={{ display: "block", marginTop: "0.25rem" }}>Ghi chú: {data.notes || "—"}</Text>
                  <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                    Cập nhật: {formattedDate}
                  </Text>
                  <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.25rem", display: "block" }}>
                    Object ID: {objectId}
                  </Text>
                  <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.25rem", display: "block" }}>
                    Owner: {data.owner}
                  </Text>
                </div>

                {isOwner && (
                  <form onSubmit={handleUpdate} style={{ marginBottom: "1rem" }}>
                    <Text size="3" weight="medium" style={{ display: "block", marginBottom: "0.5rem" }}>Cập nhật hồ sơ</Text>
                    <div style={{ display: "grid", gap: "0.75rem" }}>
                      <input
                        required
                        placeholder="Họ tên"
                        value={updateForm.patientName}
                        onChange={(e) => setUpdateForm({ ...updateForm, patientName: e.target.value })}
                        style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
                      />
                      <input
                        required
                        type="number"
                        min={0}
                        placeholder="Tuổi"
                        value={updateForm.age}
                        onChange={(e) => setUpdateForm({ ...updateForm, age: e.target.value })}
                        style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
                      />
                      <input
                        required
                        placeholder="Chẩn đoán"
                        value={updateForm.diagnosis}
                        onChange={(e) => setUpdateForm({ ...updateForm, diagnosis: e.target.value })}
                        style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
                      />
                      <input
                        placeholder="Thuốc"
                        value={updateForm.medications}
                        onChange={(e) => setUpdateForm({ ...updateForm, medications: e.target.value })}
                        style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)" }}
                      />
                      <textarea
                        placeholder="Ghi chú"
                        value={updateForm.notes}
                        onChange={(e) => setUpdateForm({ ...updateForm, notes: e.target.value })}
                        style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)", minHeight: 80 }}
                      />
                    </div>
                    <Button
                      style={{ marginTop: "0.75rem" }}
                      type="submit"
                      disabled={state.isLoading || state.isPending}
                    >
                      {state.isLoading || state.isPending ? <ClipLoader size={16} /> : "Lưu cập nhật"}
                    </Button>
                  </form>
                )}

                {isOwner && (
                  <form onSubmit={handleTransfer} style={{ marginBottom: "1rem" }}>
                    <Text size="3" weight="medium" style={{ display: "block", marginBottom: "0.5rem" }}>Chuyển quyền sở hữu</Text>
                    <input
                      required
                      placeholder="Địa chỉ mới"
                      value={transferTo}
                      onChange={(e) => setTransferTo(e.target.value)}
                      style={{ padding: "0.5rem", borderRadius: 8, border: "1px solid var(--gray-a6)", width: "100%" }}
                    />
                    <Button
                      style={{ marginTop: "0.75rem" }}
                      type="submit"
                      disabled={state.isLoading || state.isPending}
                    >
                      {state.isLoading || state.isPending ? <ClipLoader size={16} /> : "Chuyển quyền"}
                    </Button>
                  </form>
                )}

                <Flex gap="2" style={{ marginBottom: "1rem" }}>
                  <Button
                    size="2"
                    variant="soft"
                    onClick={actions.clearObject}
                  >
                    Xóa & tạo mới
                  </Button>
                </Flex>

                {state.hash && (
                  <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--gray-a3)", borderRadius: "8px" }}>
                    <Text size="1" style={{ display: "block", marginBottom: "0.5rem" }}>Transaction Hash</Text>
                    <Text size="2" style={{ fontFamily: "monospace", wordBreak: "break-all" }}>{state.hash}</Text>
                    {state.isConfirmed && (
                      <Text size="2" style={{ color: "green", marginTop: "0.5rem", display: "block" }}>
                        Transaction confirmed!
                      </Text>
                    )}
                  </div>
                )}

                {state.error && (
                  <div style={{ marginTop: "1rem", padding: "1rem", background: "var(--red-a3)", borderRadius: "8px" }}>
                    <Text style={{ color: "var(--red-11)" }}>
                      Error: {(state.error as Error)?.message || String(state.error)}
                    </Text>
                  </div>
                )}
              </div>
            ) : (
              <div style={{ padding: "1rem", background: "var(--yellow-a3)", borderRadius: "8px" }}>
                <Text style={{ color: "var(--yellow-11)" }}>Object not found</Text>
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  Object ID: {objectId}
                </Text>
                <Button
                  size="2"
                  variant="soft"
                  onClick={actions.clearObject}
                  style={{ marginTop: "1rem" }}
                >
                  Clear & Create New
                </Button>
              </div>
            )}
          </div>
        )}
      </Container>
    </div>
  )
}

export default SampleIntegration

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0xbab08a38bc4814d96cf8edaaf731a17cabf02f1f606f3cb949c48ae5691443ee` and Module: `contract`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
